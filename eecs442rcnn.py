# -*- coding: utf-8 -*-
"""EECS442RCNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1REnTFgArM2q7O1aPS-TkRXE4vK-Ep_7q
"""

from google.colab import drive
drive.mount('/content/drive')

# use tensor flow in order to use the vgg16
import tensorflow as tf
import os,cv2,keras
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf

path = "/content/drive/MyDrive/442final/442_take2/test_images_1"
annot = "/content/drive/MyDrive/442final/442_take2/test_annotation_1"

def get_iou(box1, box2):
    # Calculate intersection area
    x1 = max(box1['x1'], box2['x1'])
    y1 = max(box1['y1'], box2['y1'])
    x2 = min(box1['x2'], box2['x2'])
    y2 = min(box1['y2'], box2['y2'])
    intersection = max(0, x2 - x1 + 1) * max(0, y2 - y1 + 1)

    # Calculate union area
    area1 = (box1['x2'] - box1['x1'] + 1) * (box1['y2'] - box1['y1'] + 1)
    area2 = (box2['x2'] - box2['x1'] + 1) * (box2['y2'] - box2['y1'] + 1)
    union = area1 + area2 - intersection

    # Calculate IoU
    iou = intersection / union
    return iou

train_images=[]
train_labels=[]
svm_image = [];
svm_label = [];
for e,i in enumerate(os.listdir(annot)):
  try:
      if i.startswith("balloon_dream"):
          annot_name = i.split(".")[0]+".jpg"
          # balloon_dream_1_000
          filename = i.split(".")[0]
          # ballon dream 1 000
          filename = filename.split("_")
          filename = "_".join([filename[0], filename[1], filename[3]])
          filename = filename + ".jpg"
          print(e,filename)
          image = cv2.imread(os.path.join(path,filename))
          # df = pd.read_csv(os.path.join(annot,i))
          df = pd.read_csv(os.path.join(annot,i.replace(".jpg",".csv")), header=None, delimiter='\s+')
          gtvalues=[]



          for index, row in df.iterrows():
            series = row.iloc[-1]
            row1 = series.split(',')
            if len(row1) < 4:
              continue

            x1 = int(row1[0])
            x2 = int(row1[1])
            y1 = int(row1[2])
            y2 = int(row1[3])
            gtvalues.append({"x1":x1,"x2":x2,"y1":y1,"y2":y2})
            timage = image[x1:x2,y1:y2]
            if timage.shape[1] == 0 or timage.shape[1] == 0:
              continue
            resized = cv2.resize(timage, (224,224), interpolation = cv2.INTER_AREA)
            svm_image.append(resized)
            svm_label.append([1])


          ss.setBaseImage(image)   # setting given image as base image
          ss.switchToSelectiveSearchFast()     # running selective search on base image
          ssresults = ss.process()     # processing to get the outputs
          imout = image.copy()
          counter = 0
          falsecounter = 0
          flag = 0
          fflag = 0
          bflag = 0

          for e, result in enumerate(ssresults):
            if e < 2000 and flag == 0:
                for gtval in gtvalues:
                    x, y, w, h = result
                    try:
                        iou = get_iou(gtval, {"x1": x, "x2": x + w, "y1": y, "y2": y + h})
                    except Exception as e:
                        print(f"IoU calculation error: {e}")
                        # continue
                    if counter < 50:
                        if iou > 0.70:
                            try:
                                if w == 0 or h ==0:
                                  continue  # Skip this region if width or height is zero
                                # print("Bounding Box Dimensions:", x, y, w, h)
                                timage = imout[x:x+w, y:y+h]
                                if timage.shape[1] == 0 or timage.shape[0] == 0:
                                    print("Cropped Region Shape:", timage.shape)
                                    continue
                                else:
                                    resized = cv2.resize(timage, (224, 224), interpolation=cv2.INTER_AREA)
                                    train_images.append(resized)
                                    train_labels.append(1)
                                    counter += 1
                                # print("Cropped Region Shape:", timage.shape)
                                # resized = cv2.resize(timage, (224,224), interpolation=cv2.INTER_AREA)
                            except Exception as e:
                                print(f"Error resizing positive example: {e}")
                    else:
                      # have enough sample
                        fflag = 1
                    if falsecounter < 30:
                        if iou < 0.3:
                            try:
                                if w == 0 or h ==0:
                                  print("1 Bounding Box Dimensions:", x, y, w, h)
                                  timage = imout[x:x+w, y:y+h]
                                  print("Cropped Region Shape:", timage.shape)
                                  resized = cv2.resize(timage, (224,224), interpolation=cv2.INTER_AREA)
                                  # print("Error: Zero width or height detected in image region. Skipping...")
                                  continue  # Skip this region if width or height is zero
                                else:
                                  # print("2 Bounding Box Dimensions:", x, y, w, h)
                                  timage = imout[x:x + w, y:y + h]
                                  print("Cropped Region Shape:", timage.shape)
                                  if timage.shape[1] == 0:
                                    print("Cropped Region Shape:", timage.shape)
                                    continue
                                  else:
                                    resized = cv2.resize(timage, (224, 224), interpolation=cv2.INTER_AREA)
                                    train_images.append(resized)
                                    train_labels.append(0)
                                    svm_image.append(resized)
                                    svm_label.append([0])
                                    falsecounter += 1
                            except Exception as e:
                                # print("Bounding Box Dimensions:", x, y, w, h)
                                # print("Cropped Region Shape:", timage.shape)
                                print(f"Error resizing negative example: {e}")
                    else:
                        bflag = 1
                if fflag == 1 and bflag == 1:
                    print("inside")
                    flag = 1

  except Exception as e:
      print(e)
      print("error in "+filename)
      continue

X_new = np.array(train_images)
Y_new = np.array(train_labels)

# fine tune
vgg = tf.keras.applications.vgg16.VGG16(include_top=True, weights='imagenet', input_tensor=None, input_shape=None, pooling=None, classes=1000)
for layer in vgg.layers[:-2]:
  layer.trainable = False
x = vgg.get_layer('fc2')
last_output =  x.output
x = tf.keras.layers.Dense(1,activation = 'sigmoid')(last_output)
model = tf.keras.Model(vgg.input,x)
model.compile(optimizer = "adam",
              loss = 'binary_crossentropy',
              metrics = ['acc'])

model.fit(X_new,Y_new,batch_size = 64,epochs = 3, verbose = 1,validation_split=.05,shuffle = True)
model.save_weights("myweights.h5")

print(len(svm_image))
print(len(svm_label))
!cd "/content/drive/MyDrive/442final/"
!ls

x =model.get_layer('fc2').output
Y = tf.keras.layers.Dense(1)(x)
final_model = tf.keras.Model(model.input,Y)
final_model.compile(loss='hinge',
              optimizer='adam',
              metrics=['accuracy'])
final_model.summary()
final_model.load_weights('myweights.h5')

hist_final = final_model.fit(np.array(svm_image),np.array(svm_label),batch_size=32,epochs = 20,verbose = 1,shuffle = True,validation_split = 0.05)

import matplotlib.pyplot as plt
print(hist_final.history.keys())
plt.plot(hist_final.history['loss'])
plt.plot(hist_final.history['val_loss'])
plt.title("model loss")
plt.ylabel("Loss")
plt.xlabel("Epoch")
plt.legend(["Training Loss","Validation Loss"])
plt.show()
plt.savefig('chart loss.png')

import collections
result_dict = {}
###########  it's time for test a image    ##########
# for i in range(45)
image = cv2.imread(os.path.join(path,'tojime_no_siora_006.jpg'))
ss.setBaseImage(image)
ss.switchToSelectiveSearchFast()
ssresults = ss.process()

imOut = image.copy()
boxes = []
count = 0
# key score: val the 4 num
print(len(ssresults))
for e,result in enumerate(ssresults):
  if e < 50:
    x,y,w,h = result
    print(x, y, w, h)
    timage = imout[x:x+w,y:y+h]
    if timage.shape[1] == 0:
      continue
    resized = cv2.resize(timage, (224,224), interpolation = cv2.INTER_AREA)
    resized = np.expand_dims(resized,axis = 0)
    out = final_model.predict(resized)
    print(e,out[0][0])
    result_dict[out[0][0]] = result
    # if(out[0][0]<out[0][1]):
    if (out[0][0] > 0 and abs(float(out[0][0])) > 1):
      print("box found")
      boxes.append([x,y,w,h])
      count+=1

import matplotlib.pyplot as plt

# Extract scores from result_dict
scores = list(result_dict.keys())

# Plot histogram
plt.hist(scores, bins=10, edgecolor='black')
plt.xlabel('Score')
plt.ylabel('Frequency')
plt.title('Histogram of Scores')
plt.show()